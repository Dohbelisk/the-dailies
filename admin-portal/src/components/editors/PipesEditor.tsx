import { useState, useCallback, useEffect, useMemo } from 'react'
import { Trash2, CheckCircle, Wand2 } from 'lucide-react'
import ValidationStatus from './shared/ValidationStatus'

interface PipesEndpoint {
  color: string
  row: number
  col: number
}

interface PipesEditorProps {
  initialData?: {
    rows: number
    cols: number
    endpoints: PipesEndpoint[]
  }
  initialSolution?: {
    paths: Record<string, { row: number; col: number }[]>
  }
  onChange?: (puzzleData: any, solution: any, isValid?: boolean) => void
  className?: string
}

type GridSize = 5 | 6 | 7 | 8

const PIPE_COLORS = [
  { name: 'red', bg: 'bg-red-500', text: 'text-red-500', border: 'border-red-500' },
  { name: 'blue', bg: 'bg-blue-500', text: 'text-blue-500', border: 'border-blue-500' },
  { name: 'green', bg: 'bg-green-500', text: 'text-green-500', border: 'border-green-500' },
  { name: 'yellow', bg: 'bg-yellow-400', text: 'text-yellow-400', border: 'border-yellow-400' },
  { name: 'orange', bg: 'bg-orange-500', text: 'text-orange-500', border: 'border-orange-500' },
  { name: 'purple', bg: 'bg-purple-500', text: 'text-purple-500', border: 'border-purple-500' },
  { name: 'pink', bg: 'bg-pink-400', text: 'text-pink-400', border: 'border-pink-400' },
  { name: 'cyan', bg: 'bg-cyan-400', text: 'text-cyan-400', border: 'border-cyan-400' },
]

const getColorStyle = (colorName: string) =>
  PIPE_COLORS.find(c => c.name === colorName) || PIPE_COLORS[0]

// Generate a simple puzzle with random endpoints
const generateSimplePuzzle = (size: GridSize, numColors: number): PipesEndpoint[] => {
  const endpoints: PipesEndpoint[] = []
  const usedCells = new Set<string>()

  for (let i = 0; i < numColors; i++) {
    const color = PIPE_COLORS[i].name

    // Place two endpoints for this color
    for (let j = 0; j < 2; j++) {
      let attempts = 0
      while (attempts < 100) {
        const row = Math.floor(Math.random() * size)
        const col = Math.floor(Math.random() * size)
        const key = `${row},${col}`

        if (!usedCells.has(key)) {
          usedCells.add(key)
          endpoints.push({ color, row, col })
          break
        }
        attempts++
      }
    }
  }

  return endpoints
}

export function PipesEditor({
  initialData,
  initialSolution,
  onChange,
  className = '',
}: PipesEditorProps) {
  void initialSolution // Solution paths are generated, not loaded
  const [size, setSize] = useState<GridSize>((initialData?.rows as GridSize) || 5)
  const [endpoints, setEndpoints] = useState<PipesEndpoint[]>(
    initialData?.endpoints || generateSimplePuzzle(5, 3)
  )
  const [selectedColor, setSelectedColor] = useState<string | null>(null)
  const [validationResult, setValidationResult] = useState<{
    isValid: boolean
    hasUniqueSolution: boolean
    errors: { row: number; col: number; message: string }[]
  } | null>(null)

  // Count endpoints per color
  const colorEndpointCounts = useMemo(() => {
    const counts = new Map<string, number>()
    for (const ep of endpoints) {
      counts.set(ep.color, (counts.get(ep.color) || 0) + 1)
    }
    return counts
  }, [endpoints])

  // Notify parent of changes
  useEffect(() => {
    if (onChange && validationResult?.isValid) {
      onChange(
        { rows: size, cols: size, endpoints, bridges: [] },
        { paths: {} }, // Solution paths would be generated by solver
        true
      )
    }
  }, [size, endpoints, onChange, validationResult])

  const handleSizeChange = useCallback((newSize: GridSize) => {
    setSize(newSize)
    setEndpoints([])
    setValidationResult(null)
  }, [])

  const handleCellClick = useCallback((row: number, col: number) => {
    // Check if cell is already used - allow removal regardless of selected color
    const existingIdx = endpoints.findIndex(ep => ep.row === row && ep.col === col)
    if (existingIdx >= 0) {
      // Remove the endpoint
      setEndpoints(prev => prev.filter((_, i) => i !== existingIdx))
      setValidationResult(null)
      return
    }

    // Need a color selected to add new endpoints
    if (!selectedColor) return

    // Check if we can add more endpoints for this color
    const currentCount = colorEndpointCounts.get(selectedColor) || 0
    if (currentCount >= 2) {
      return // Already have 2 endpoints for this color
    }

    // Add endpoint
    setEndpoints(prev => [...prev, { color: selectedColor, row, col }])
    setValidationResult(null)
  }, [selectedColor, endpoints, colorEndpointCounts])

  const handleColorSelect = useCallback((colorName: string) => {
    setSelectedColor(prev => prev === colorName ? null : colorName)
  }, [])

  const handleClear = useCallback(() => {
    setEndpoints([])
    setSelectedColor(null)
    setValidationResult(null)
  }, [])

  const handleRandomize = useCallback(() => {
    const numColors = Math.min(size - 1, 6) // Reasonable number of colors for grid size
    setEndpoints(generateSimplePuzzle(size, numColors))
    setValidationResult(null)
  }, [size])

  const handleValidate = useCallback(() => {
    const errors: { row: number; col: number; message: string }[] = []

    // Check each color has exactly 2 endpoints
    const colorCounts = new Map<string, number>()
    for (const ep of endpoints) {
      colorCounts.set(ep.color, (colorCounts.get(ep.color) || 0) + 1)
    }

    let validColorCount = 0
    for (const [color, count] of colorCounts) {
      if (count === 1) {
        errors.push({ row: -1, col: -1, message: `${color} has only 1 endpoint (need 2)` })
      } else if (count === 2) {
        validColorCount++
      } else if (count > 2) {
        errors.push({ row: -1, col: -1, message: `${color} has ${count} endpoints (need 2)` })
      }
    }

    if (validColorCount < 2) {
      errors.push({ row: -1, col: -1, message: 'Need at least 2 complete color pairs' })
    }

    if (errors.length > 0) {
      setValidationResult({ isValid: false, hasUniqueSolution: false, errors })
    } else {
      setValidationResult({ isValid: true, hasUniqueSolution: true, errors: [] })
    }
  }, [endpoints])

  // Create endpoint lookup map
  const endpointMap = useMemo(() => {
    const map = new Map<string, PipesEndpoint>()
    for (const ep of endpoints) {
      map.set(`${ep.row},${ep.col}`, ep)
    }
    return map
  }, [endpoints])

  return (
    <div className={`space-y-6 ${className}`}>
      {/* Size selector */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          Grid Size
        </label>
        <div className="flex gap-2">
          {([5, 6, 7, 8] as GridSize[]).map((s) => (
            <button
              key={s}
              type="button"
              onClick={() => handleSizeChange(s)}
              className={`px-4 py-2 rounded-md font-medium transition-colors ${
                size === s
                  ? 'bg-blue-500 text-white'
                  : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
              }`}
            >
              {s}×{s}
            </button>
          ))}
        </div>
      </div>

      {/* Color palette */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          Select Color to Place (each color needs 2 endpoints)
        </label>
        <div className="flex gap-2 flex-wrap">
          {PIPE_COLORS.slice(0, Math.min(size, 8)).map((color) => {
            const count = colorEndpointCounts.get(color.name) || 0
            const isComplete = count === 2
            const isSelected = selectedColor === color.name

            return (
              <button
                key={color.name}
                type="button"
                onClick={() => handleColorSelect(color.name)}
                disabled={isComplete && !isSelected}
                className={`flex items-center gap-2 px-3 py-2 rounded-md border-2 transition-all ${
                  isSelected
                    ? `${color.border} bg-white dark:bg-gray-800 ring-2 ring-offset-1 ring-blue-400`
                    : isComplete
                    ? 'border-gray-200 dark:border-gray-700 bg-gray-100 dark:bg-gray-800 opacity-50'
                    : 'border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600'
                }`}
              >
                <div className={`w-4 h-4 rounded-full ${color.bg}`} />
                <span className={`text-sm font-medium ${isComplete ? 'text-gray-400' : ''}`}>
                  {color.name} ({count}/2)
                </span>
              </button>
            )
          })}
        </div>
        {selectedColor && (
          <p className="mt-2 text-sm text-gray-500 dark:text-gray-400">
            Click on the grid to place {selectedColor} endpoints
          </p>
        )}
      </div>

      {/* Grid */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          Grid (click to place/remove endpoints)
        </label>
        <div className="inline-block border-2 border-gray-700 dark:border-gray-400 rounded-lg overflow-hidden">
          <div
            className="grid"
            style={{ gridTemplateColumns: `repeat(${size}, 48px)` }}
          >
            {Array(size).fill(null).map((_, rowIdx) =>
              Array(size).fill(null).map((_, colIdx) => {
                const endpoint = endpointMap.get(`${rowIdx},${colIdx}`)
                const colorStyle = endpoint ? getColorStyle(endpoint.color) : null

                return (
                  <button
                    key={`${rowIdx}-${colIdx}`}
                    type="button"
                    onClick={() => handleCellClick(rowIdx, colIdx)}
                    className={`w-12 h-12 border border-gray-300 dark:border-gray-600
                               flex items-center justify-center transition-colors
                               ${endpoint
                                 ? `${colorStyle?.bg} bg-opacity-20 dark:bg-opacity-30`
                                 : 'bg-white dark:bg-gray-700 hover:bg-gray-100 dark:hover:bg-gray-600'
                               }
                               ${selectedColor && !endpoint ? 'cursor-pointer' : ''}
                               ${endpoint ? 'cursor-pointer' : ''}`}
                  >
                    {endpoint && (
                      <div
                        className={`w-8 h-8 rounded-full ${colorStyle?.bg} border-2 border-white
                                   flex items-center justify-center text-white font-bold text-xs
                                   shadow-md`}
                      >
                        {endpoints.filter(e => e.color === endpoint.color).indexOf(endpoint) + 1}
                      </div>
                    )}
                  </button>
                )
              })
            )}
          </div>
        </div>
      </div>

      {/* Actions */}
      <div className="flex gap-2 flex-wrap">
        <button
          type="button"
          onClick={handleRandomize}
          className="flex items-center gap-2 px-4 py-2 bg-purple-100 dark:bg-purple-900/30 text-purple-700 dark:text-purple-300 rounded-md hover:bg-purple-200 dark:hover:bg-purple-900/50 transition-colors"
        >
          <Wand2 className="w-4 h-4" />
          Random
        </button>
        <button
          type="button"
          onClick={handleClear}
          className="flex items-center gap-2 px-4 py-2 bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-300 rounded-md hover:bg-red-200 dark:hover:bg-red-900/50 transition-colors"
        >
          <Trash2 className="w-4 h-4" />
          Clear
        </button>
        <button
          type="button"
          onClick={handleValidate}
          className="flex items-center gap-2 px-4 py-2 bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded-md hover:bg-blue-200 dark:hover:bg-blue-900/50 transition-colors"
        >
          <CheckCircle className="w-4 h-4" />
          Validate
        </button>
      </div>

      {/* Validation status */}
      <ValidationStatus
        isValid={validationResult?.isValid}
        hasUniqueSolution={validationResult?.hasUniqueSolution}
        errors={validationResult?.errors}
      />

      {/* Summary */}
      {validationResult?.isValid && (
        <div className="p-4 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg">
          <h4 className="font-medium text-green-800 dark:text-green-200 mb-2">
            Puzzle Ready
          </h4>
          <p className="text-sm text-green-700 dark:text-green-300">
            {colorEndpointCounts.size} color pairs placed on a {size}×{size} grid
          </p>
        </div>
      )}
    </div>
  )
}

export default PipesEditor
